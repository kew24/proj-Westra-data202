---
title: "Genetic Mutations from Cancer Therapies"
author: "Kaitlyn Westra"
date: "Fall 2020"
output: 
  github_document:
    toc: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r quietly-install-packages, include=FALSE}
library(tidyverse)
```

### About

This is an outline of the things that need to be included for this final project. Below, I've copied & pasted the project outline from Professor Arnold's project description. Interspersed is bullet points of specific rubric objectives (copied & pasted from the "3 points" column in Moodle). This hopefully makes it easier to see what progress has been made & what we have left to do. At the very end, when these sections are filled in, the filler words can be deleted.

## Introduction

*Nature Genetics* is one of the most well-known and well-respected journals in the field of genetics. The work that these articles are based on reflect years of rigorous research, and presents some of the latest and greatest ideas in the field. Due to this, many experts regard getting published in the journal as a great achievement and frequently read these published articles. 

Over the past 6 months, I've worked as a research intern at Grand Rapids' Van Andel Institute, in a [lab](https://braslab.vai.org) that studies the genetics of neurodegenerative diseases, like Parkinson's Disease, Alzhiemer's Disease, and dementia with Lewy bodies. Throughout this internship, I have been able to learn about the intersection of genetics, disease, and data science, using R and other genomics tools to analyze genetic mutation data and make discoveries that have an impact on people's lives.  

Because of this introduction I've had to the field of genetics annd bioinformatics, I have been curious what *other* labs and groups do with similar data. This lead me to browse through the [cBioPortal for Cancer Genomics](https://www.cbioportal.org), which I had heard about from a series of online [Dataviz + Cancer Microlabs](https://apply.hub.ki/cancerplusviz/) that occured earlier this year. The dataset I had found was used in a recent *Nature Genetics* article, "[Cancer therapy shapes the fitness landscape of clonal hematopoiesis](https://www.nature.com/articles/s41588-020-00710-0)" so I decided this would be perfect for my final project.

## Question

#### Background

The story behind this article follows first author Kelly Bolton, a physician scientist (MD-PhD) and first year fellow in medical oncology at Memorial Sloan Kettering, the worldâ€™s oldest and largest private cancer center. Bolton was new to studying clonal hematopoiesis (CH), but jumped on the opportunity to research it, especially to understand if specific therapy types resulted in a higher frequency of CH. With her knowledge of epidemiology, she realized that she could use data from both electronic health records and sequential samples from patients, to understand how therapy could be promoting pre-existing CH or inducing new mutations.  

CH essentially happens when a hematopoietic stem cell, which can develop into different types of blood cells, starts making cells with the same genetic mutation in individuals without a blood disease. As such, clonal hematopoiesis [includes](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC7065480/) the entire spectrum of premalignant conditions related to somatic mutations in genes associated with myeloid disorders. CH remains benign in most people, but sometimes progresses to malignancy. 

Previously, studies have shown that certain types of chemotherapy lead to a higher risk of developing myeloid neoplasms (a class of clonal hematopoietic stem cell disorders), and also that the presence of clonal hematopoiesis increases the risk of developing these therapy-related myleoid neoplasm diseases (tMNs). Thus, the relationship between specific therapies and CH is important to investigate. Understanding this relationship can aid in the understanding of the mechanisms by which therapy-related myeloid diseases occur, and from there, can help develop interventions. 

#### Project

With this project, I aim to replicate this lab's findings that mutations in genes are enriched based on specific exposures. Specifically, I will set out to verify that "**mutations in *ASXL1* are enriched in current or former smokers, whereas cancer therapy with radiation, platinum and topoisomerase II inhibitors preferentially selects for mutations in DNA damage response genes (*TP53*, *PPM1D*, *CHEK2*).**"

To do so, I will be recreating their **Figure 1c** using exactly the same data the authors used, and a combination of their published R code and some of my own original code. In this process, I will be thoroughly narrating my steps to give insight into the process and decisions that were made. Because a big part of data science and computer science is looking through others' code, understanding it, and adapting it to fit your needs, doing so with this available example will be an exercise in this skill. Being able to accomplish the objectives I have outlined herein demonstrate the knowledge I've gained this semester in DATA-202, and that I am equipped to practically apply this in new situations. 


> *Much of the technical background information, including specific phrases, in this section was found in Bolton's [Nature Research blog post](https://cancercommunity.nature.com/posts/cancer-therapy-shapes-the-fitness-landscape-of-clonal-hematopoiesis).*


## Dataset

```{r load-M_wide_all}
M_wide_all = suppressWarnings(data.table::fread('./data/M_wide_all.txt', sep = '\t', header = T)) %>%
  as.data.frame()
```

The dataset used in Figure 1c is originally called `M_wide_all`. It contains brings together data on patients' demographics, exposures, and blood/tumor mutations. Used together, this information allows for correlations to be tested. 

The `M_wide_all` dataset was obtained directly from the lab's available [Github repo](https://github.com/papaemmelab/bolton_NG_CH) for this project. Descriptions of how this data was originally acquired, though, are found in the Methods section of the published paper. While a comprehensive overview of the exact details can be found in the paper, a summary is provided here as well. Patients in the MSK-IMPACT cohort had nonhematologic cancers at Memorial Sloan Kettering (MSK) Cancer Center, and data on these patients' ancestry, smoking, date of birth and cancer history was extracted from the MSK cancer registry. Additional blood sample data was added from their Serial Sampling cohort. All participants underwent matched tumor and blood sequencing, which encompassed the exomes of all cancer-associated genes. After sequencing, variant calling for each blood sample was performed by various methods, and variants that were called by two callers were retained. Further, variants were annotated, leaving us with the dataset that appears to be `M_wide_all`. 

> *Much of the technical methods information, including specific phrases, in this section was found in the [Nature Article](https://www.nature.com/articles/s41588-020-00710-0) itself.*

I am comfortable saying the data is reliable due to the fact that the authors followed standard scientific protocols, the study was reviewed and accepted by a Institutional Review Board, and the final paper was peer reviewed and published in a high impact journal. Additionally, because this data is from real patients in a well known cancer treatment / research institution, this data is applicable to the questions the authors set out to answer.

`M_wide_all` contains `r nrow(M_wide_all)` rows, with `r ncol(M_wide_all)` columns, making it an extremely large dataset. Because there are `r M_wide_all$STUDY_ID %>% as.factor %>% nlevels()` unique `STUDY_ID`s and `r nrow(M_wide_all)` rows in this dataset, we know that the `STUDY_ID` acts as a unique identifier for every row. Each row contains data from one patient and their blood/tumor, with columns for:    
- their `STUDY_ID`  
- the presence/number of mutations in each specific gene (`BRCA1`, `DNAJB1`, `ERBB4`, `FOXO1`, `TET2`, `TP53`, etc.)  
- information about these mutations' variant allele fraction (`VAF_all`, `VAF_nonsilent`, `VAF_silent`, `VAF_my`, etc.)  
- the number of different types of mutations (`mutnum_all`, `mutnum_nonsilent`, `mutnum_my`, etc.)  
- the presence of clonal hematopoiesis mutations (`ch_nonmy`, `CH_nonsilent`, `ch_my_pd` [PD being "putative cancer-driver mutations"], etc.)  
- demographic information about the patient (`Gender`, `race`, `age`)  
- the patient's exposures (`therapy_known`, `therapy_binary`, `smoke`, `ind_cytotoxic_therapy`, `ind_ds_fluorouracil`, etc.). 

This very large dataset is appropriate for answering the question answered in Figure 1c. As stated above, there are columns for mutations in many specific genes, which is what we are measuring. Additionally, there are columns for the exposures as well, including Therapy and Smoking. As these are the two primary things shown in Figure 1c, this dataset is applicable to our question of interest. 

This dataframe is read in with `fread`, and most columns' data type is as expected. However, there are some instances where I think it would be best if the data were factors (many of the indicator variables or categories) but instead, they are coded as integers or strings. In all of our columns, the data types are broken down below:

```{r datatypes-table, echo=FALSE}
knitr::kable(table(sapply(M_wide_all, class)), col.names = c("Type", "# of Columns"))
```

Some examples of variables I think should be renamed include: 

```{r datatypes-ideal, echo=FALSE}
data.frame(Variable = c("Gender",
                        "ind_ds_fluorouracil",
                        "age_cat",
                        "smoke"),
           `CurrentType` = c(typeof(M_wide_all$Gender),
                              typeof(M_wide_all$ind_ds_fluorouracil),
                              typeof(M_wide_all$age_cat),
                              typeof(M_wide_all$smoke)),
           `IdealType` = c(rep("factor",4))) %>%
  knitr::kable(col.names = c("Variable", "Current Type", "Ideal Type"))
```

As seen in the table above, I would change most datatypes to factor, which could be easily done with the `data.table::fread()` option, `stringsAsFactors = TRUE`. It would make sense to change these to factors due to their use in this analysis -- `Gender` was essentially considered a factor, with the following options: `r M_wide_all$Gender %>% as.factor() %>% levels()`, and the indicator variables (like `ind_ds_fluorouracil`) having the following levels: `r M_wide_all$ind_ds_fluorouracil %>% as.factor() %>% levels()`. I am unsure of why they chose to leave strings as characters, but because it doesn't really affect the analysis, this isn't an imperative issue.

With the knowledge of which variable names are included in this dataset, it makes sense to explore individual variables further and determine what they mean, what the distribution looks like, and how they're related to other variables. This allows us to to make choices about how to further interpret and analyze this data, as well as give some ideas on which data wrangling steps need to be taken.

#### Exploratory Data Analysis and Data Wrangling

In `M_wide_all`, it appears as if some preprocessing steps have already been taken, such as adding a column for the age categories -- breaking down each person's exact decimal age, into an age bracket. To explore how these age categories are broken down, I did the following:

```{r age-bars}
#how many age groups are there?
table(M_wide_all$age_cat) %>%
  as.data.frame() %>%
  rename(`Age Group` = Var1,
         `Number of People` = Freq) %>%
  knitr::kable()

ggplot(data = as.data.frame(table(M_wide_all$age_cat)), aes(x = Var1, y = Freq)) +
  geom_col(fill = "#5691c1") +
  theme_classic() +
  labs(x = "Age Group", y = "Number of People")
```

From the above, we know that there are 9 different age categories, each with the specified number of people. This distribution is left-skewed, and most people appear to be in the higher numbered age groups.

To gain an understanding of what ages are included in each group, I did the following:

```{r age-boxes}
#give min of each boxplot / age group:
age_cutoffs <- c()
for (num in 1:9) {
  age_cutoffs <- c(age_cutoffs, M_wide_all[M_wide_all$age_cat == num,] %>%
    select(age) %>%
    min())
}
split_age_box <- ggplot(M_wide_all, aes(y = age, x = as.factor(age_cat), fill = as.factor(age_cat))) +
  geom_boxplot() +
  scale_fill_brewer(palette = "BuGn") +
  theme_classic() +
  theme(legend.position = "none") +
  labs(x = "Age Group", y = "Age", fill = "Age Group") +
  scale_y_continuous(breaks = c(0, 11, 21, 31, 41, 51, 61, 71, 81),
                   labels = c(0, 11, 21, 31, 41, 51, 61, 71, 81)) +
  geom_hline(aes(yintercept = age_cutoffs[2]), linetype = "dashed", color = "grey") +
  geom_hline(aes(yintercept = age_cutoffs[3]), linetype = "dashed", color = "grey") +
  geom_hline(aes(yintercept = age_cutoffs[4]), linetype = "dashed", color = "grey") +
  geom_hline(aes(yintercept = age_cutoffs[5]), linetype = "dashed", color = "grey") +
  geom_hline(aes(yintercept = age_cutoffs[6]), linetype = "dashed", color = "grey") +
  geom_hline(aes(yintercept = age_cutoffs[7]), linetype = "dashed", color = "grey") +
  geom_hline(aes(yintercept = age_cutoffs[8]), linetype = "dashed", color = "grey") +
  geom_hline(aes(yintercept = age_cutoffs[9]), linetype = "dashed", color = "grey")

together_age_violin <- ggplot(M_wide_all, aes(y = age, x = 0)) +
  geom_violin(fill = "white") +
  theme_void() +
  labs(x = "Full Dataset", y = "Age") +
  theme(axis.ticks.x = element_blank(),
        axis.text.x = element_blank())

cowplot::plot_grid(split_age_box, together_age_violin, ncol = 2, rel_widths = c(.75, .25), align = "h")
```

As shown above, the age cutoffs for each categroy are: `r age_cutoffs`, indicating that they chose 0, 11, 21, 31, 41, 51, 61, 71, 81 as their minimum ages for each age group. These cutoffs appear in grey dashed lines on the series of boxplots, demonstrating that these categories are chosen based on age itself, as opposed to having category containing the same number of people (e.g., 9 quantiles). The violin plot shown demonstrates how many samples are included in the entire dataset, by age, aligned with the violin plots to give a insight into the comparative amount of patients in each group. 

Some of the other variables that are primarily used to create Figure 1c are `race`, `mutnum_all`, `smoke`, `Gender`, and `therapy_binary`. However, before creating the figure, they "process dataframes a bit", which I'll walk through next. 

```{r dataframe-processing}
M_wide_all = M_wide_all %>%
    mutate(race_b = as.integer(race == "White")) %>%
    mutate(age_scaled = as.vector(scale(age)),
           age_d=age/10) %>%
    mutate(mutnum_all_r = case_when(
      mutnum_all == 0 ~ 0,
      mutnum_all == 1 ~ 1,
      mutnum_all >= 2 ~ 2)) %>%
    mutate(smoke_bin=case_when(
      smoke==0 ~ 0,
      smoke==1 ~ 1,
      smoke==2 ~ 1)) %>%
    mutate(
      Gender = relevel(factor(Gender), ref = 'Male'),
      race = relevel(factor(race), "White"),
      smoke = relevel(factor(smoke), "0"),
      smoke_bin = relevel(factor(smoke_bin), "0"),
      therapy_binary = relevel(factor(therapy_binary), 'untreated')
    )
```

This step of consecutive mutating essentially makes a lot of the variables of interest into a binary factor, which is similar to what I had suggested with the original dataframe. In these above steps, the following variables are created:

- `race_b`: a binary version of `race`, with a value of 1 for "White", and a 0 for anything else. 
- `age_scaled`: the `age` value, centered (by subtracting the mean `age`) and scaled (by dividing the centered `age` by its standard deviation).  
- `age_d`: simply takes the `age` value and divides it by 10.  
- `mutnum_all_r`: the number of mutations, with a value of 2 for any individual with 2+ mutations.  
- `smoke_bin`: a binary version of `smoke`, with a value of 1 if patient is a current (`smoke` value of 1) or former (`smoke` value of 2) smoker 


In the last step of the above code, the variables `Gender`, `race`, `smoke`, `smoke_bin`, and `therapy_binary` are factored and releveled with specific references. 
- Reference values are important when modelling because any differences are in comparison to the reference category. Because its the basis for which values are compared to, this can change the interpretation of the reuslts.  
- After releveling, the resulting base level for the following values are:  
<ul>
  - `Gender`: Male
  - `race`: White  
  - `smoke`: 0 (never smoker)  
  - `smoke_bin`: 0 (never smoker)  
  - `therapy_binary`: untreated (no cancer directed therapy during interval other than hormonal therapy)  
</ul>

To observe some of these changes, we'll look at what these variables look like before and after the change:

**Number of Mutations**

Originally, the number of mutations, `mutnum_all`, is broken down into `r M_wide_all$mutnum_all %>% as.factor() %>% nlevels()` categories. The new variable, `mutnum_all_r`, only has `r M_wide_all$mutnum_all_r %>% as.factor() %>% nlevels()` categories. Below is the breakdown of each of these:

```{r mutnum_table, echo=FALSE}
table(M_wide_all$mutnum_all) %>%
  knitr::kable(col.names = c("Number of Mutations","Number of People"),
               caption = "mutnum all",
               format = "html")
table(M_wide_all$mutnum_all_r) %>%
  knitr::kable(col.names = c("Number of Mutations","Number of People"),
               caption = "mutnum all r",
               format = "html")
```

From this, we see that any people with more than 2 mutations have been included in the `mutnum_all_r` "2" category.

**Age Scaling**

```{r mutate-changes}
original_age_density <- ggplot(data = M_wide_all, aes(x = age)) +
  geom_density(fill = "#5691c1") +
  theme_classic() +
  labs(x = "Age", y = "Number of People") +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank())

scaled_age_denstiy <- ggplot(data = M_wide_all, aes(x = age_scaled)) +
  geom_density(fill = "#5691c1") +
  theme_classic() +
  labs(x = "Scaled Age", y = "Number of People") +
  theme(axis.ticks.y = element_blank(),
        axis.text.y = element_blank()) +
  scale_x_continuous(position = "top") +
  scale_y_reverse()
cowplot::plot_grid(original_age_density, scaled_age_denstiy, nrow = 2, align = "v")
```

In the above plot, the distribution of `age` is shown on top of the distribution of `age_scaled`. The distribution itself is the same, but the age values change (due to the centering and scaling). To see the new values, note the different x-axis value range for `age_scaled`.

From this point, the dataset was wrangled to create a new dataset:

```{r wide-with-treatment}
#Define wide data frame with treatment known
M_wide <- M_wide_all %>% filter(therapy_known==1)
```

In this newly created dataset, `M_wide`, contains only the row where the therapy information is known. This is an appropriate way to identify and deal with missing data, as it ensures that the data we're using allows for the comparisons to be made.



## Exploratory Data Analysis

Show plots illustrating the distribution of at least 4 variables in your dataset. Comment on anything interesting you observe.

- **Univariate EDA**: Includes insightful / thoughtful commentary on implications of the distributions plotted (perhaps how that informs further analysis)  
    - more than: *Includes plots illustrating the distribution of more than one variable in the dataset, with some commentary.*



Show plots illustrating bivariate relationships for at least 2 pairs of variables. Explain what you observe (e.g., positive/negative correlation, no correlation, etc.).

- **Bivariate EDA**: Includes insightful / thoughtful commentary on the implication of the relationships plotted  
    - more than: *Includes plots illustrating bivariate relationships for at least 2 pairs of variables and some description of observations (e.g., strength of relationship, dependence on other factors).*
  
Before creating the actual model used in Figure 1c, I decided to do a series of quick plots to see what relationsips might be present between our variables of interest. 





## Modeling

From the figure legend, we see that the question in Figure 1c is whether *specific molecular subtypes of CH-PD correlate with age, previous therapy exposure and smoking history*. The authors answer this question by creating *multivariable logistic regression models adjusted for therapy, smoking, ancestry, age, sex and time from diagnosis to blood draw.* In Figure 1c, they display the odds ratio with its 95% confidence interval for CH-PD mutations in the ten most commonly mutated genes. They show three consecutive forest plots displaying different groups compared; for the top, increasing age (n = 10,138); middle, patients previously exposed to cancer therapy (n = 5,978) compared with those with no exposure (n = 4,160); bottom, current/former smokers (n = 4,989) compared with nonsmokers (n = 5,145). Significance levels are determined by Q values (FDR-corrected P values): \* Q < 0.05, \*\* Q < 0.01, \*\*\* Q < 0.001. 



Clearly state what is the target variable you are trying to predict, which variables (features) you are using to predict it, and why you chose those features.

- **Modeling setup/ task description**: Modeling task is both clearly described and well motivated (e.g., alternative decisions are identified and considered)  
    - more than: *Clear description of the model setup. e.g., for a predictive model, what are the features and targets, why those were chosen, what validation method was employed and why, etc.*


Fit a basic predictive model using one of the techniques we discussed in class (regression: Nearest Neighbors or Linear Regression, classification: Nearest Neighbors or Logistic Regression; other choices such as Decision Trees are also fine)


Report the results of your basic predictive model on held-out data or via cross-validation.

- **Modeling baselie results**: A baseline was thoughtfully chosen and evaluated.  
    - more than: *Results of a correctly applied baseline model are reported correctly*


Make one or more changes to the predictive model to improve the accuracy. Discuss what changes you made, why you made them, and what the results were.

- **Modeling refinements**: Particular thought or insight was given to the choice of changes to make and/or analysis of their implications.  
    - more than: *Reports what changes were made, why they were made, and what the results were.*


**Alternative**: instead of a supervised prediction task, you can define an unsupervised learning task and use clustering. In this case, clearly state what you want to understand through the clustering, and report your observations.

[FIXTHIS: pick up on rubric here... **Discussion of findings**]

Direct Code from Reviewer_Code.Rmd (from here, I just need 1c):

```{r reviewer-code, eval=FALSE}
## Main figures
# Figure 1 - mutational characteristics
hide_this_too <- function(){
  # panel_theme = theme_bw() + theme(
  #     panel.border = element_blank(),
  #     legend.position = "none",
  #     panel.grid.minor = element_blank(),
  #     plot.subtitle = element_text(hjust = 0.5, size = 8),
  #     plot.title = element_text(face = 'bold', size = 12, hjust = 0, vjust = -11),
  #     panel.grid.major = element_blank(),
  #     strip.background = element_blank(),
  #     strip.text = element_text(size = 6),
  #     axis.text.y = element_text(size = 6),
  #     axis.text.x = element_text(size = 6),
  #     axis.title = element_text(size = 8),
  #     axis.line = element_line(),
  #     plot.margin = unit(c(0,0,0,0), 'pt')
  # ) 
  # 
  # age_groups = c("0-10", "11-20", "21-30", "31-40", "41-50", "51-60", "61-70", "71-80", "81-90", "91-100")
  # 
  # get_ch_grouped = function(M_wide, CI = T) {
  # 
  #     CH_by_age_grouped = M_wide %>% select(STUDY_ID, age_cat, CH) %>%
  #         mutate(CH = ifelse(is.na(CH), 0, CH)) %>%
  #         group_by(age_cat) %>%
  #         summarise(CH = sum(CH), total = n()) %>% 
  #         filter(!is.na(age_cat)) %>%
  #         mutate(freq = CH / total)
  #     
  #     if (CI) {
  #         CH_by_age_grouped = CH_by_age_grouped %>%
  #         cbind(
  #             apply(CH_by_age_grouped, 1, function(row) {
  #                 CI = prop.test(row['CH'], row['total'], conf.level=0.95)$conf.int[1:2]
  #                 return(c(lower = CI[1], upper = CI[2]))
  #             }) %>% t
  #         )
  #     }
  #     
  #     return(CH_by_age_grouped)
  # }
  # 
  # font_size = 8
  # age_curve_theme = 
  #   theme(
  #       legend.position = 'top',
  #       legend.key.size = unit(5, 'mm'),
  #       legend.title = element_blank(),
  #       legend.direction = 'horizontal',
  #       plot.title = element_text(hjust = -0.08),
  #       axis.text.x = element_text(angle = 45, vjust = 0.5, size = font_size),
  #       axis.text.y = element_text(size = font_size),
  #       axis.title = element_text(size = font_size),
  #       legend.text = element_text(size = font_size)
  #   )
}

hide_for_now <- function() {
  # this is a fake function for me to be able to hide this section of the chunk while still keeping it in (using RStudio's nice arrow things). Eventually, I will delete this, but I wanted to keep it in for a bit. 
  # ## Histogram by gene frequency
  # gene_list = M %>% count(Gene) %>% arrange(-n) %>% .$Gene %>% unique %>% .[1:10]
  # 
  # n_treated = M_wide %>% count(therapy_binary) %>% filter(therapy_binary == 'treated') %>% pull(n)
  # n_untreated = M_wide %>% count(therapy_binary) %>% filter(therapy_binary == 'untreated') %>% pull(n)
  # 
  # # tally
  # D = M %>% 
  #     filter(CH_nonsilent == 1) %>%
  #     reshape2::dcast(
  #         formula = Gene + therapy_binary ~ .,
  #         value.var = 'STUDY_ID',
  #         fun.aggregate = function(STUDY_IDs) {length(unique(STUDY_IDs))}
  #     ) %>%
  #     dplyr::rename("n_patient" = ".") %>%
  #     mutate(
  #         prop_patient = case_when(
  #             therapy_binary == 'treated' ~ n_patient/n_treated,
  #             therapy_binary == 'untreated' ~ n_patient/n_untreated
  #         )
  #     ) %>%
  #     filter(Gene %in% gene_list) %>%
  #     mutate(
  #         Gene = factor(Gene, gene_list),
  #         therapy_binary = factor(therapy_binary, c('untreated', 'treated'))
  #     ) %>%
  #     arrange(Gene)
  # 
  # # need to test for ch_nonsilent, the gene columns in M_wide are ch_pancan_pd
  # asterisks = lapply(gene_list, 
  #     function(gene) {
  #         model = glm(
  #             formula = paste0(gene, ' ~ age_scaled + smoke_bin + race_b + Gender + therapy_binary'),
  #             data = M_wide,
  #             family = "binomial")
  #         treatment_pval = model %>% summary %$% coefficients %>% .['therapy_binarytreated', 'Pr(>|z|)']
  #         treatment_qval = p.adjust(treatment_pval, method = 'fdr', n = length(gene_list))
  #         return(signif.num(treatment_qval, ns = F))
  #     }
  # )
  # 
  # p_hist = ggplot(
  #       D,
  #       aes(x = Gene, y = prop_patient, fill = therapy_binary)
  #   ) +
  #   geom_bar(stat = 'identity', position = "dodge", color = 'black', size = 0.25) +
  #   panel_theme +
  #   theme(
  #       panel.grid.major = element_blank(), 
  #       panel.border = element_blank(),
  #       axis.line = element_line(colour = "black"),
  #       legend.title = element_blank(),
  #       legend.key.size = unit(5, 'mm'),
  #       legend.position = 'top',
  #       legend.direction = 'horizontal',
  #       axis.title = element_text(size = font_size),
  #       axis.text.x = element_text(angle = 45, hjust = 1, size = font_size),
  #       legend.text = element_text(size = font_size)
  #   ) +
  #   annotate('text', x = gene_list, y = 0.11, label = asterisks, size = 4) +
  #   ylab("Proportion with mutated Gene") +
  #   xlab('') +
  #   scale_fill_manual(values = therapy_colors) +
  #   scale_color_manual(values = therapy_colors)
}

## forest plot
DTA = c('DNMT3A', 'TET2', 'ASXL1')
DDR = c('PPM1D', 'TP53', 'CHEK2')
SPL = c('SF3B1', 'SRSF2')
OTH = c('JAK2', 'ATM')

gene_list = c(DDR, DTA, SPL, OTH)

#ALL adjusted for treatment
logit_gene_var = list()

for (gene in gene_list) {
    logit = glm(
        formula = get(gene) ~ age_scaled + smoke_bin + race_b + Gender + therapy_binary,
        data = M_wide,
        family = "binomial")
    logit_data = logit %>% sjPlot::get_model_data(type="est") %>% cbind(Gene = gene)
    logit_gene_var = rbind(logit_gene_var, logit_data)
}

# for each gene
D = logit_gene_var %>%
    filter(!term %in% c("GenderFemale", "race_b")) %>%
    mutate(
        term = c(
            'therapy_binarytreated' = 'Therapy',
            'smoke_bin1' = 'Smoking',
            'age_scaled' = 'Age'
        )[as.character(term)]
    ) %>%
    mutate(term = factor(term, c("Age", "Therapy", "Smoking"))) %>%
    mutate(p_fdr = p.adjust(p.value, method = "fdr")) %>%
    mutate(termGene = paste0(term, Gene)) %>%
    arrange(estimate, Gene) %>%
    mutate(termGene = factor(termGene, levels = termGene)) %>%
    mutate(gene_cat = case_when(
        Gene %in% DTA ~ 'DTA', 
        Gene %in% DDR ~ 'DDR', 
        Gene %in% SPL ~ 'Splicing', 
        T ~ 'Other'
      )
    ) %>% 
    mutate(gene_cat = factor(gene_cat, c('DDR', 'DTA', 'Splicing', 'Other'))) %>%
    mutate(
        q.value = p.adjust(p.value, n = nrow(.), method = 'fdr'), #"p.adjust" adjusts p-values for multiple comparisons (using the Benjamini & Hochberg (1995) correction method)
        q.label = paste0(signif(estimate, 2), signif.num(q.value)),
        q.star = signif.num(q.value)
    )

p_forest = plot_forest(
      D,
      x = "termGene",
      label = 'q.star',
      eb_w = 0,
      eb_s = 0.3,
      ps = 1.5,
      or_s = 2,
      nudge = -0.3,
      col = 'gene_cat'
  ) + 
  facet_wrap(~term, scale = 'free_y', ncol = 1) +
  scale_x_discrete(
      breaks = D$termGene,
      labels = D$Gene,
      expand = c(0.1,0)
  ) +
  xlab('') + ylab('Odds Ratio of CH-PD') +
  scale_color_nejm() +
  panel_theme +
  theme(
    axis.text = element_text(size = font_size),
    axis.title = element_text(size = font_size),
    strip.text = element_text(size = font_size),
    legend.position = 'top',
    legend.title = element_blank(),
    legend.text = element_text(size = font_size/1.2),
    legend.key.size = unit(3, "mm")
  ) 

combo = ((p_hist + labs(title = 'A')) / (p_stack + labs(title = 'B'))) | (p_forest+ labs(title = 'C'))

do_plot(combo, "fig1c.png", 10, 6, save_pdf = F) #no pdf
```






## Findings:  

Summarize the analyses you performed and what the results told you. What do your findings say about the real-world and prediction (or clustering) questions you posed?






## Limitations: 

What are some limitations of your analyses and potential biases of the data you used?





## Future Directions: 

What new questions came up following your exploration of this data? Describe at least one question that could not be answered using your data alone, and specify what additional data you would collect to address it.


## Conclusions

> this is my own added section. see if I want to include this or not. if not, put this paragraph somewhere else


In addressing this question, I gained not only an understanding of how data science is used in my chosen career field, but also an appreciation for the hard work done by women in STEM -- as, to my surprise, first author Kelly Bolton MD PhD, as well as lab PI, Elli Papaemmanuil, PhD, are both women. 

## Appendix


```{r all-code, ref.label=knitr::all_labels(), eval=FALSE}
```

